\documentclass[pagesize=a4]{scrreprt}

\title{Implementing Gauss's Lemma in Lean}
\author{Aditya Agarwal}

\usepackage{amsmath}
\usepackage{amsthm,amssymb} 
\usepackage{listings}
\usepackage{graphicx} 
\usepackage[utf8x]{inputenc}
\usepackage{hyperref}


\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\begin{document}
\maketitle

\chapter{Background}

I attempted to implement a proof of Gauss's Lemma in Lean over the Australian summer of 2018-2019. This report provides the background on Lean and the Gauss Lemma, and details my (yet incomplete) proof.  

\section{Lean}

Lean is an Interactive theorem prover that implements mathematics using a form of dependent type theory known as the Calculus of Inductive Constructions. 

\subsection{Interactive Theorem Proving}

Interactive Theorem Provers are tools for writing proofs in formal mathematics that seek to abstract away the low level busy work. They work by having humans guide them by suggesting which ``tactic'' to use, and showing what they have inferred. For example 

For example, to prove that any reducible non-unit can be written as a product of two non-units, we may want to work with the definition of irreducibility. 

\smallskip

\begin{center}

\includegraphics{tactic_example.png}\footnote{Forgive the code screenshots. Getting Unicode to work in \LaTeX turned out to be rather daunting. }

\end{center}
\smallskip

So we can tell the theorem prover to unfold the definition of irreducibility, at which point it will inform us on what the new state of the proof is. 

\smallskip
\begin{center}

\includegraphics{tactic_state.png}

\end{center}
As we can see here, it has updated \texttt{hp} be $\neg$(definition of irreducibility). So by specifying which tactic to use, we may guide the theorem prover towards the proof. 

These tactics help the prover generate a proof, that is fed into a proof verifier, which then checks the correctness of the proof. 

In Lean, we may also interface with the proof verifier directly, in what is known as ``term mode''. 

For example, we show $0 + x = x$ by induction. Here $s$ is the successor operation, and $z$ is zero. 


\smallskip

\begin{center}

\includegraphics{term_example.png}

\end{center}

\subsection{Dependent Type Theory}

The Calculus of Constructions that Lean implements is a form of Dependent Type Theory, an alternative axiomatisation of mathematics. Rather than being constructed out of sets, each object has a fixed type, that type belongs to some universe $u$. 

For example, 

\begin{itemize}
    \item $n : \N$ $n$ belongs to the type of natural numbers. 
    \item $p \iff  p : Prop$ - $p \iff p$ is a proposition, which is also a type. 
\end{itemize}

This type may depend on a parameter such as 

\begin{itemize}
  \item $\text{list } \alpha$
  \item $\text{polynomial } \alpha$
\end{itemize}

We also have the notion of $\Pi$-types and $\Sigma$-types, which build new types out of other types. 

$\Pi$ types denote the notion of a dependent function type. A function whose return type may depend on the input parameter. E.g. the function $f(a) := x + a$ that takes an $a$ in any ring $\alpha$, returns $x + a$ in $\alpha[x]$

$$C :\Pi\ \alpha : \texttt{Type u}, \alpha \rightarrow \texttt{polynomial } \alpha $$

Similarly, $\Sigma$-types denote the cartesian product, where the type for the second element is allowed to depend on the first. 

i.e. $\Sigma\ \alpha\ \beta$ denotes the type $\alpha \times \beta$, where $\beta$ is allowed to depend on the type of $ \alpha$. 

\subsection{Mathlib}

Mathlib is the mathematical components library for Lean. 

It contains the beginnings of Algebra, Analysis, Topology, some elementary Number Theory. On the Algebra side, it contains basic definitions about Groups, Rings, Modules etc. And properties about Integral Domains, Euclidean Domains, Unique Factorisation Domains etc. 

I initially wanted to do some Algebraic Number Theory, but found Galois Theory was missing entirely. So I chose to implement the Gauss Lemma, the first step towards implementing Galois Theory.\footnote{My first plan was to work all the way to the Fundamental Theorem of Galois Theory, but that $grossly$ overestimated how fast I could implement proofs in Lean.} 

\subsubsection{Implementation Style in Mathlib}

Generally, mathlib implements theories in the most abstract setting possible. 

For example, polynomial is defined as

\includegraphics{polynomial.png}

Which is a function from $\N$ to the commutative semiring of coefficients $\alpha$ with a finite support (i.e. only finitely many non-zero values in the image). 

  This is largely motivated by the desire for code reuse. By defining properties in the most general setting possible, we can reuse them across many instances.

 For example, We know that any ordered finite set has a maximum. This property can be used wherever ordered finite sets come up. 
        Like to argue that a polynomial has a coefficient of maximum degree. The support of polynomial is finite and has a natural order. So ordered finsets having a maximum gives us the existence of a coefficient of maximum degree automatically.


 While an alternative implementations like lists of coefficients would require a separate proof about the fact. 


 Similarly, it provides a uniform API between components of the library. 

 However, this can make definitions non-intuitive, which can slow down the development process. 


\section{Gauss's Lemma}

Before implementing it in Lean, we recall the statement and proof the Gauss Lemma. 

\begin{theorem}[Gauss's Lemma]
    Let $\alpha$ be a Unique Factorisation Domain. 

    Let $p$ be a polynomial with coefficients in $\alpha$. Then $p$ factors in $\alpha[X]$ if and only if it factors in $Frac(\alpha)[X]$.
\end{theorem}

Before we can prove Gauss's Lemma, we need to prove Gauss's Primitive Polynomial Lemma. 

\begin{definition}[Primitive Polynomial]

    Let $p$ be a polynomial in $\alpha[X]$. We say $p$ is primitive if the only constants in $ \alpha $ which divide $p$ are units. 

\end{definition}


\begin{lemma}[Gauss's Primitive Polynomial Lemma]
    Let $p$ and $q$ be primitive polynomials. Then $pq$ is a primitive polynomial.
\end{lemma}

\begin{proof}
    Assume for a contradiction that $pq$ is not primitive. 
    Then we have some $c \in \alpha$ such that $c$ is not a unit and $c \mid p$. 
   
    $\alpha$ is a UFD, so $c$ has some irreducible factor that divides $pq$. So WLOG, we may assume $c$ is irreducible, and hence prime.

    $\therefore \alpha/(c)$ is a domain.
    
    $\therefore \alpha/(c) [x]$ is a domain. 

    $c \mid pq$ so $pq$ vanishes in $\alpha/(c) [x]$. 

    As $\alpha/(c) [x]$ is an Integral Domain, $p$ vanishes or $q$ vanishes in $\alpha[X]$.

   $\therefore c \mid p$ or $c \mid q$. 
    
   $\therefore$ Either $p$ is not primitive or $q$ is not primitive. 

   This is a contradiction. Hence $pq$ must be primitive. 
  \end{proof}

  Now we prove Gauss's Lemma. 

  \begin{proof}

    Let $p$ be an irreducible in $\alpha$. Any irreducible term must be primitive, so we know $p$ is primitive. 

    Suppose for a contradiction that $p$ is not irreducible in $Frac (\alpha)$. 

    Then $p = ab$, for some $a,b \in Frac (\alpha)[x]$. 

    We may multiply $a$ and $b$ by some $c_1,c_2 \alpha$ so that $c_1a,c_2b$ have $\alpha$ coefficients. $c_1c_2p = c_1ac_2b$. 
    We can factor $c_1a$ to some $c_1'a'$ and $c_2b$ to $c_2'b'$, so that $a'$ and $b'$ are primitive. 

    Hence $p = \frac{c_1'c_2'}{c_1c_2}a'b'$.

    Let $k =  \frac{c_1'c_2'}{c_1c_2}$

    We note that $k$ must be in $\alpha$, because otherwise 
if $k$ is not in $\alpha$, it's denominator (in reduced form) must divide each coefficient of $a'b'$. This is because $p =  ka'b'$ has $\alpha$ coefficients. 
  
    Hence $a'b'$ is not primitive. But by the primitive polynomial lemma, we know $a'b'$ is primitive. This is a contradiction. 

    But now we have produced a non-trivial factorisation for $p$ in $\alpha[X]$, namely $ka'b'$. This is a contradiction. 
    
    So it follows that if p is irreducible in  $\alpha[X]$ is irreducible in $Frac(\alpha[X])$


  \end{proof}


\chapter{Implementation Overview} 

My implementation is available at \url{https://github.com/chocolatier/theoremproving}. 

Note: as of commit 745d1d79e473eb48788be8ba8b3cfb6774c424a7, not all the functions I describe are present/implemented. This is because I am in the middle of a code refactor, the reasons explained later. 

The implementation of the forward direction of the Gauss Lemma itself is split into three separate lemmas. 

\begin{itemize}
    \item \texttt{can\_factor\_poly}: Which states that any reducible polynomial $p$ in $Frac(\alpha)[X]$ can be written as $kd'd_2'$, where $k$ is in $Frac(\alpha)$, and $d', d_2'$ are primitive polynomials in $ \alpha[X]$. 
    
        \includegraphics[width=\textwidth]{can_factor_poly.png}

    This largely a straightforward calculation. 

    \item \texttt{prim\_associate}: If $p$ and $q$ are primitive polynomials, $r$ is in $Frac(\alpha)$, and $p = rq$, then $r$ must be an integer. 
    
    \includegraphics{prim_associate.png}

    This was implemented as a proof by contradiction in my previous iteration, where I argued that $r$ would have to be in the form $a^{-1}$, for some $a \in \alpha$. 
    
    I had sorried this fact, but the human proof is that if $p = \frac{m}{n}q$, where $n$ is not a unit and $n, m$ are coprime, then $np = mq$. This is a contradiction, because the LHS and RHS have distinct coprime factors. 

    And then I did a fairly longwinded deduction (full of sorries) showing that since $a \mid c_i$, for all coefficients $c_i$ of $q$, because each $a^{-1}c_i$ corresponded to some coefficient $c'_i$ of $p$, q was not primitive. 

    I believe the argument I provided in the human proof above will be easier to implement in the refactor. 

     \item{irred\_in\_base\_imp\_irred\_in\_quot}: The forward direction of the Gauss Lemma. 
    
    \includegraphics{prod_base.png}

    It largely puts the above two lemmas together, and does some simple deduction to argue why a witness to reducibility constitutes an contradiction. 

\end{itemize}


This depended on The Primitive Polynomial Lemma, which was implemented in two parts. 

\begin{itemize}
   \item A polynomial being primitive is defined as it having no constant divisors. 

   \includegraphics{def_prim.png}

   \item \texttt{div\_pq\_imp\_div\_p\_or\_q}: If an irreducible $r$ in $\alpha$ divides $pq$ then it must divide $p$ or it must divide $q$. 

    \includegraphics{div_pq.png}

    This should be extremely straightforward, since $\alpha/(r)$ is an integral domain if $r$ is prime is already present in mathlib. As is $R[X]$ being an integral domain if $R$ is.

    But unfortunately, just stating that $f = 0$ in $\alpha/(r)[X]$ makes the type class resolutions time out. So the core of the proof remains unimplemented.

    \item \texttt{prod\_of\_prim\_is\_prim} : The product of two primitive polynomials is primitive. 
    
    \includegraphics{prod_prim.png} 

    This is again the proof by contradiction mentioned in the previous section. 

\end{itemize}


Each of the proofs above depend on numerous subsidiary lemmas that I wouldn't bother proving to another human, but Lean cannot infer on it's own. Such as texttt{not\_irred\_imp\_prod}: Any reducible element can be written as a product of other non-units. Each of these are also quite straightforward to implement. 

While once everything is implemented, it is straightforward, getting there wasn't.  

\chapter{Challenges in Implementation}

\end{document}